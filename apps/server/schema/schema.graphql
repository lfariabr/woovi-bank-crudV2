
type AuthPayload {
  token: String!
  account: Account!
}

input LoginInput {
  email: String!
  password: String!
}

input RegisterInput {
  email: String!
  password: String!
  first_name: String
  last_name: String
  taxId: String!
  accountId: String!
}

type Mutation {
  login(input: LoginInput!): AuthPayload
  register(input: RegisterInput!): AuthPayload
  AccountAdd(input: AccountAddInput!): AccountAddPayload
  AccountUpdate(input: AccountUpdateInput!): AccountUpdatePayload
  MessageAdd(input: MessageAddInput!): MessageAddPayload
}

type Query {
  me: Account
}

type Query {
  accounts(
    after: String
    first: Int
    before: String
    last: Int
  ): AccountConnection
  messages(
    after: String
    first: Int
    before: String
    last: Int
  ): MessageConnection
  transactions(
    after: String
    first: Int
    before: String
    last: Int
    account_id_sender: String
    account_id_receiver: String
    amount: Float
  ): TransactionConnection
}

type Account implements Node {
  id: ID!
  first_name: String
  last_name: String
  email: String
  taxId: String
  accountId: String
  createdAt: String
  isActive: Boolean
  balance: Float
}

type AccountConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge]
}

type AccountEdge {
  node: Account
  cursor: String!
}

type AccountAddPayload {
  account: Account
  clientMutationId: String
}

input AccountUpdateInput {
  id: ID!
  first_name: String
  last_name: String
  email: String
  taxId: String
  accountId: String
  isActive: Boolean
  balance: Float
  clientMutationId: String
}

input AccountAddInput {
  first_name: String!
  last_name: String!
  email: String!
  taxId: String!
  accountId: String!
  clientMutationId: String
}

type AccountAddedPayload {
  account: Account
  clientSubscriptionId: String
}

input AccountAddedInput {
  clientSubscriptionId: String
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type MessageEdge {
  node: Message
  cursor: String!
}

type Message implements Node {
  id: ID!
  content: String
  createdAt: String
}

interface Node {
  id: ID!
}

type AccountUpdatePayload {
  account: Account
  clientMutationId: String
}

type MessageAddPayload {
  message: Message
  clientMutationId: String
}

input MessageAddInput {
  content: String!
  clientMutationId: String
}

type Subscription {
  AccountAdded(input: AccountAddedInput!): AccountAddedPayload
  AccountUpdated(input: AccountUpdatedInput!): AccountUpdatedPayload
  MessageAdded(input: MessageAddedInput!): MessageAddedPayload
  TransactionAdded(input: TransactionAddedInput!): TransactionAddedPayload
}

input AccountUpdatedInput {
  clientSubscriptionId: String
}

type AccountAddedPayload {
  account: Account
  clientSubscriptionId: String
}

type AccountUpdatedPayload {
  account: Account
  clientSubscriptionId: String
}

type MessageAddedPayload {
  message: Message
  clientSubscriptionId: String
}

input MessageAddedInput {
  clientSubscriptionId: String
}

###############
# Transaction #
###############

type Transaction implements Node {
  id: ID!
  amount: Float!
  account_id_sender: String!
  account_id_receiver: String!
  createdAt: String!
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]
}

type TransactionEdge {
  node: Transaction
  cursor: String!
}

input SendTransactionInput {
  accountIdReceiver: String!
  amount: Float!
  clientMutationId: String
}

type SendTransactionPayload {
  transaction: Transaction
  clientMutationId: String
}

extend type Mutation {
  sendTransaction(input: SendTransactionInput!): SendTransactionPayload
}

input TransactionAddedInput {
  clientSubscriptionId: String
}

type TransactionAddedPayload {
  transaction: Transaction
  clientSubscriptionId: String
}