
type AuthPayload {
  token: String!
  account: Account!
}

input LoginInput {
  email: String!
  password: String!
}

input RegisterInput {
  email: String!
  password: String!
  firstName: String
  lastName: String
  taxId: String!
  accountId: String!
}

type Mutation {
  login(input: LoginInput!): AuthPayload
  register(input: RegisterInput!): AuthPayload
}

type Query {
  me: Account
}

type Query {
  accounts(
    after: String
    first: Int
    before: String
    last: Int
  ): AccountConnection
  messages(
    """Returns the items in the list that come after the specified cursor."""
    after: String

    """Returns the first n items from the list."""
    first: Int

    """Returns the items in the list that come before the specified cursor."""
    before: String

    """Returns the last n items from the list."""
    last: Int
  ): MessageConnection
}

type Account implements Node {
  id: ID!
  first_name: String
  last_name: String
  email: String
  taxId: String
  accountId: String
  createdAt: String
}

type AccountConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge]
}

type AccountEdge {
  node: Account
  cursor: String!
}

type AccountAddPayload {
  account: Account
  clientMutationId: String
}

input AccountAddInput {
  first_name: String!
  last_name: String!
  email: String!
  taxId: String!
  accountId: String!
  clientMutationId: String
}

type AccountAddedPayload {
  account: Account
  clientSubscriptionId: String
}

input AccountAddedInput {
  clientSubscriptionId: String
}

"""A connection to a list of items."""
type MessageConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [MessageEdge]
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type MessageEdge {
  """The item at the end of the edge"""
  node: Message

  """A cursor for use in pagination"""
  cursor: String!
}

"""Represents a message"""
type Message implements Node {
  """The ID of an object"""
  id: ID!
  content: String
  createdAt: String
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type Mutation {
  AccountAdd(input: AccountAddInput!): AccountAddPayload
  AccountUpdate(input: AccountUpdateInput!): AccountUpdatePayload
  MessageAdd(input: MessageAddInput!): MessageAddPayload
}

type AccountUpdatePayload {
  account: Account
  clientMutationId: String
}

type MessageAddPayload {
  message: Message
  clientMutationId: String
}

input MessageAddInput {
  content: String!
  clientMutationId: String
}

type Subscription {
  AccountAdded(input: AccountAddedInput!): AccountAddedPayload
  AccountUpdated(input: AccountUpdatedInput!): AccountUpdatedPayload
  MessageAdded(input: MessageAddedInput!): MessageAddedPayload
}

type AccountAddedPayload {
  account: Account
  clientSubscriptionId: String
}

type AccountUpdatedPayload {
  account: Account
  clientSubscriptionId: String
}

type MessageAddedPayload {
  message: Message
  clientSubscriptionId: String
}

input MessageAddedInput {
  clientSubscriptionId: String
}